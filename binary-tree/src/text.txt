#[derive(PartialEq, PartialOrd, Debug)]
struct TreeNode<T> {
    value: T,
    left: Box<Option<TreeNode<T>>>, // Pode ser uma ref pra n√£o usar box
    rigth: Box<Option<TreeNode<T>>>,
}

#[derive(PartialEq, PartialOrd, Debug)]
struct BinaryTree<T> {
    root: Option<TreeNode<T>>,
}

impl<T> TreeNode<T> {
    fn new(value: T) -> TreeNode<T> {
        Self {
            value,
            left: Box::new(None),
            rigth: Box::new(None),
        }
    }
}

impl<T: PartialEq + PartialOrd + Clone> BinaryTree<T> {
    fn new(value: T) -> BinaryTree<T> {
        Self {
            root: Some(TreeNode::new(value)),
        }
    }
    fn insert(self, new_node_value: T) -> BinaryTree<T> {
        let new_node = TreeNode::new(new_node_value);

        match self.root {
            Some(node) => {
                if new_node.value <= node.value {
                    self.root = Box::new(Some(new_node));
                    return Self {
                        root: Some(TreeNode {
                            value: node.value,
                            left: Box::new(Some(TreeNode::new(new_node_value))),
                            rigth: Box::new(None),
                        }),
                    };
                } else if new_node.value > node.value {
                    return Self {
                        root: Some(TreeNode {
                            value: node.value,
                            left: Box::new(None),
                            rigth: Box::new(Some(TreeNode::new(new_node_value))),
                        }),
                    };
                }

                Self { root: None }
            }
            None => Self::new(new_node_value),
        }
    }
}

fn main() {
    let tree = BinaryTree::new(1);

    let tree = tree.insert(2);

    let tree = tree.insert(3);

    let tree = tree.insert(4);

    let tree = tree.insert(4);

    dbg!(tree);
}
